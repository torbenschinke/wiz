the wiz book
============
Torben Schinke
v1.0, 2017-12-05
:doctype: book
:source-highlighter: rouge
:toc:
:toc-placement: preambe

[dedication]
Dedication
----------
For the family.



[preface]
Preface
-------
The idea of a robust, simple and scalable storage format superseeding the 
lowest denomiator filesystems, fascinated me already 15 years ago, 
however I never had the opportunity to actually start implementing such a project. 
When the time came, I started to design a paper based specification in 2015 which 
performs well for deduplicating large files, nested directory trees and 
continues snapshots. To solve the typical problems of a 'multi file based 
document format' at work, I created a proprietary java based implementation 
from it, called wiz - which is just the opposite of a git, similarities are 
purely coincidental. For the original intention, it worked pretty well. 
But as requirements changed, the performance for a lot of additional use 
cases was disappointing. The main performance issues are caused by both, 
inherent format decisions and the necessity of a complex virtual machine. 
In practice, the latter caused also penalties on the probably most successful 
mobile platform of our time. To solve all of these issues I started to design 
an entirely new specification which addresses all of the new additional 
scenarios (and even more). Hereafter this new specification is actually 
'wiz version 3' or simply 'wiz'. Therefore the proprietary existing wiz 
implementation is called 'legacy wiz' and is not only implemented in a 
different language but also does a lot of things differently to improve 
performance, storage usage, reliability and system complexity. 
Today, the market for closed source commercial software libraries is nearly 
dead and gaining money or finding acceptance is not easy. 
Usually large companies dominate the market with a lot (but definity not all) 
high quality products.



Format specification
--------------------
Wiz is both, an implementation and a specification.
In this chapter only the specification matters and is described 
in a way that it can be implemented in any language and ecosystem.

Everything in the world of wiz is represented by a node, which always
starts with a byte identifier. Besides that, there are no other common
properties among node types. 

Some nodes support compression for their payload, but it is not a generic
feature. In contrast to that, encryption is a property of the pageing infrastructure
itself. I believe that providing unencrypted insight into meta information
is already an absolute security flaw. Examples for this are stacked filesystems
like EncFs or eCryptfs, which provides plain information about the folder structure,
amount of files and the file sizes. Keeping facts about nodes unencrypted and just
encrypt payload would be the same kind of security flaw.

Pointers to nodes have a variadic size from 2 bytes upto 20 bytes, which boils
down to a theoretical 128 bit addressing, in which the first 10 bytes refer to
the id of a virtual device (vdev) and the last 10 bytes to a physical offset. 
The additonal two bytes are caused by the overhead of the varint encoding. The vdev
is usually a simple file in your host's filesystem. Using this technique, the
pointer adapts itself to different use cases, like many small vdevs or
a single large file. The usage of a varint favors storage costs over
performance. Addressing millions of nodes, especially in independent vdev sets
- I think of an online mirror storage - would waste a lot of space. In this
scenario, one could argue that the performance penalties are also on 
the client side and will not stress the server at all.

All texts should be encoded in UTF-8, however there is no simple answer for filepaths.
When taking a look at Git and how it handles filenames, it works perfectly on
Linux filesystems, which just treat a filename as a byte sequence but fails
miserably when mixing platforms like MacOS and Windows. Some users expect an
UTF-8 normalization and others excoriate that. So we also keep that decision to
a preprocess. Moreover, instead of following the errornous c approach of zero 
termination, we also use a varint as a length encoding, which has the same
overhead for most expected strings (up to 127 byte, runes may vary). We define
a text payload always as UTF-8 (a varint prefixed array of uint8) and undefined
text payload as a varint prefixed array of uint8.

In general, byte order is the common network order - big endian. Most elements
are already invariant to endianess, like varint or arrays. There is no expectation
that a specialization to the host endianess will actually result in any performance
gain, for an implementation of this specification.


In the following, offsets are always defined in hexadecimal values prefixed by
0x.

.specification of types
[width="100%",options="header"]
|==============================================
| Size | Type |  Description
| 1-10 |varuint |  unsigned, as defined in <<varint>>
| 1-10 |varint |  signed, as defined in <<varint>>
| 1-10 |vdev id| varint id, must be unique within a vdev set
| 2-20 |ndptr |  a node pointer is a double varint 128 bit address, where the first 10 byte determine the vdev id and the last 10 byte determine the physical offset in the vdev.
|1-*|utf8| UTF-8 sequences are encoded with a prefix of the type 'varuint' followed by an arbritary amount of bytes
|==============================================

Magic node
~~~~~~~~~~
Marks a container and must be always the first node of a file and should not 
occur once again. If it does (e.g. for recovery purposes), it is not allowed 
to be contradictory. Wiz containers can simply be identified using the magic 
bytes '[0x00 0x77 0x69 0x7a 0x63]'.


.on-disk format of the magic node
[width="100%",options="header"]
|==============================================
| Offset| Size | Type | Name | Value | Description
| 0x00 |1 |uint8 | node type | 0x00 | type 'header'
| 0x01 |4 |[]uint8 | magic | [77 69 7a 63] | the magic header value
| 0x05 |4 |[]uint8 | sub magic | [* * * *] | the user defined sub magic header value
| 0x09 |4 |uint32 | version | 0x03 | this is the third version of the wiz format
| 0x13 |1 |uint8 | encryption type | * | the kind of encryption algorithm
|==============================================


The 'version' indicates which nodes and how they are defined. 
A node format may be changed in future revisions but should be 
extended in a backwards compatible manner. If such a thing is not 
possible (e.g. also by adding new kinds) the number increases. Because
the format depends on the node kind (and therefore the sizes to parse)
an outdated reader can actually only use it's recovery options to continue
reading.


_Some notes to the version flag: Actually this is the third generation of the 
wiz format. The first only existed on paper, the second was implemented largely 
based on the paper based specification but is proprietary. So this is the first 
which is now open source. It is not only implemented in a different language but 
also does a lot of things differently to improve performance, storage usage, 
reliability and system complexity._

The known sub format identifiers of all known publicly available sub format 
identifiers.

.sub format identifiers
[width="100%",options="header"]
|==============================================
|Value | Description
|[77 69 7a 61] | 'wiza' the standard archive format of the command line tool
|[77 69 7a 62]| 'wizb' the format of the backup tool
|==============================================

The encryption formats are defined as follows:

.encryption format identifiers
[width="100%",options="header"]
|==============================================
|Value | Description
|0x00|no encryption, all nodes are written as they are, just in plain bytes
|0x01|AES-256 CTR mode
|==============================================


See the encryption chapter for the detailed specification of each encryption mode.

Configuration node
~~~~~~~~~~~~~~~~~~
The wiz repository (as defined by the file) may include different properties. 
These properties are important to open the repository properly, e.g. picking 
the correct hash algorithm. Also it may contain persistent optional settings for 
tweaking. This node must always be located at file offset 0x1000. It is not intended
to be modified on a regular basis.

.on-disk format of the configuration node
[width="100%",options="header"]
|==============================================
| Offset| Size | Type | Name | Value | Description
| 0x00 |1 |uint8 | node type | 0x01 | type 'configuration'
| 0x01 |*|kvobj| key value|*|key value properties in kvobj format
|==============================================

TBD define kvobj format (xdr like zfs?), better keep that small and put it into
it's own kvobj-node? (same as for nosql data nodes?)

Super node
~~~~~~~~~~
The super node is a ring buffer having 128 <<a:transaction-node,transaction entries>> which
are written in a round-robin manner. The transaction node with the highest transaction
id and a valid checksum is the transaction node to use. If something went wrong,
older transactions may be used for recovery, but the usefulness depends on the kind
of damage. Usually one would expect that if the transaction is written to the
ring buffer and the underlying file system crashes, it hopefully will loose the
data in the same order (the transaction node is always the last thing written), 
however there is no guarantee on that. Also fsync cannot protect us from that, 
because it is broken on many filesystems, even by design (see also <<btrfs-fsync>>).
Today, I don't know how to solve that properly. 

The super node is always located at file offset 0x2000 (TBD) and is defined
as follows.

.on-disk format of the super node
[width="100%",options="header"]
|==============================================
| Offset| Size | Type | Name | Value | Description
| 0x00 |1 |uint8 | node type | 0x02 | type 'super'
| 0x01 |128 * ?|[]tx-node| array|*|ring buffer of 128 transaction nodes
|==============================================

[[a:transaction-node]]
Transaction node
~~~~~~~~~~~~~~~~
The transaction node is the entry point which defines an applied transaction
and all references to nodes which describe the valid state of the storage. This
includes references to the root nodes for snapshots (equivalent to tags and branches)
and also to additional trees, holding information about reference counts and deleted
nodes. The 'transaction id' is found in all other written nodes (TBD) to easily
identify which modifications belong a specific transaction (TBD, does not make sense
when overwriting! snapshots). The id is strict monotonic increasing.

.on-disk format of the transaction node
[width="100%",options="header"]
|==============================================
| Offset| Size | Type | Name | Value | Description
| 0x00 |1 |uint8 | node type | 0x03 | type 'transaction'
| 0x01 |8|uint64| transaction id|*|increasing number
| 0x09 |8|ndptr|
|==============================================

Chapters can contain sub-sections nested up to three deep.
footnote:[An example footnote.]
indexterm:[Example index entry]

Chapters can have their own bibliography, glossary and index.

And now for something completely different: ((monkeys)), lions and
tigers (Bengal and Siberian) using the alternative syntax index
entries.
(((Big cats,Lions)))
(((Big cats,Tigers,Bengal Tiger)))
(((Big cats,Tigers,Siberian Tiger)))
Note that multi-entry terms generate separate index entries.

Here are a couple of image examples: an image:images/smallnew.png[]
example inline image followed by an example block image:

.Tiger block image
image::images/tiger.png[Tiger image]

Followed by an example table:

.An example table
[width="60%",options="header"]
|==============================================
| Option          | Description
| -a 'USER GROUP' | Add 'USER' to 'GROUP'.
| -R 'GROUP'      | Disables access to 'GROUP'.
|==============================================

.An example example
===============================================
Lorum ipum...
===============================================

[[X1]]
Sub-section with Anchor
~~~~~~~~~~~~~~~~~~~~~~~
Sub-section at level 2.

Chapter Sub-section
^^^^^^^^^^^^^^^^^^^
Sub-section at level 3.

Chapter Sub-section
+++++++++++++++++++
Sub-section at level 4.

This is the maximum sub-section depth supported by the distributed
AsciiDoc configuration.
footnote:[A second example footnote.]


The Second Chapter
------------------
An example link to anchor at start of the <<X1,first sub-section>>.
indexterm:[Second example index entry]

An example link to a bibliography entry <<taoup>>.


The Third Chapter
-----------------
Book chapters are at level 1 and can contain sub-sections.


:numbered!:

[appendix]
Example Appendix
----------------
One or more optional appendixes go here at section level 1.

Appendix Sub-section
~~~~~~~~~~~~~~~~~~~
Sub-section body.


[bibliography]
Example Bibliography
--------------------
The bibliography list is a style of AsciiDoc bulleted list.

[bibliography]
.Books
- [[[taoup]]] Eric Steven Raymond. 'The Art of Unix
  Programming'. Addison-Wesley. ISBN 0-13-142901-9.
- [[[walsh-muellner]]] Norman Walsh & Leonard Muellner.
  'DocBook - The Definitive Guide'. O'Reilly & Associates. 1999.
  ISBN 1-56592-580-7.
- [[[zfs-spec]]] http://www.giis.co.in/Zfs_ondiskformat.pdf
- [[[btrfs-fsync]]] https://btrfs.wiki.kernel.org/index.php/FAQ#Does_Btrfs_have_data.3Dordered_mode_like_Ext3.3F
- [[[varint]]] https://developers.google.com/protocol-buffers/docs/encoding

[bibliography]
.Articles
- [[[abc2003]]] Gall Anonim. 'An article', Whatever. 2003.


[glossary]
Example Glossary
----------------
Glossaries are optional. Glossaries entries are an example of a style
of AsciiDoc labeled lists.

[glossary]
A glossary term::
  The corresponding (indented) definition.

A second glossary term::
  The corresponding (indented) definition.


[colophon]
Example Colophon
----------------
Text at the end of a book describing facts about its production.


[index]
Example Index
-------------
////////////////////////////////////////////////////////////////
The index is normally left completely empty, it's contents being
generated automatically by the DocBook toolchain.
////////////////////////////////////////////////////////////////
